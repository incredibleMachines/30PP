/* Incredible Machines 2014 	cpiuggi 05/22/14  *///this is a super no no//modify the Native ArrayArray.prototype.indexOf = function(needle) {    for(var i = 0; i < this.length; i++) {        if(this[i] === needle) {            return i;        }    }    return -1;}var project = app.project;var compositions = new AEHelper("Composition")var comp = compositions.byName("Sculpt FILL")var ribs = compositions.byName("ribs")//left to rightvar layersByRow = [            [1,2,3,4],            [5,6,7,8],            [9,10,11,12],            [13,14,15,16],            [17,18,19],            [20,21,22],            [23,24],            [25,26,27],            [28,29]   ]//array of layer objects containing all the masks in the shapes groupsvar layers =[]if(comp != null){        //$.writeln(comp.numLayers)        for(var i = 1; i<= comp.numLayers;i++){          //iterate through the masks          var layerMask = comp.layer(i).property("ADBE Mask Parade")          //$.writeln("Layer Index: "+i+" | NUM Masks: "+layerMask.numProperties)          //set up all our masks for each layer          var counter = 1;          //run through all of the layerMask Properties with a custom counter          while(counter <= layerMask.numProperties){                  var sorter = []                  //create an array to sort the items by value                  //iterate through each and get the max vertices for each X                  for(var j = layerMask.numProperties; j>0 ; j--){                      var shape = layerMask.property(j).property("ADBE Mask Shape").value                      var max = { x: returnMax(shape.vertices,0), y: returnMax(shape.vertices,1)}                      if(counter == layerMask.numProperties) var min = { x: returnMin(shape.vertices,0), y: returnMin(shape.vertices,1)}                      var obj = {}                      obj.index = j                      obj.max = max                      if(counter == layerMask.numProperties){                        obj.min = min                        obj.shape = JSON.parse(JSON.stringify(shape))                        delete obj.shape.featherInterps                        delete obj.shape.featherRadii                        delete obj.shape.featherRelCornerAngles                        delete obj.shape.featherRelSegLocs                        delete obj.shape.featherSegLocs                        delete obj.shape.featherTensions                        delete obj.shape.featherTypes                       }                      sorter.push(obj)                  }                  //sort the array highest to lowest                  sorter.sort(function(a,b){return  b.max.x-a.max.x})                  //reverse them                  sorter.reverse()                  //$.writeln(JSON.stringify(sorter))                  layerMask.property(sorter[counter-1].index).moveTo(counter)                  //set the mask opacity to have a linear expression                  //layerMask.property(counter).property("Mask Opacity").expression = returnOpacityExpression(counter);                  maskOpacity(i,counter,0)                  if(counter == layerMask.numProperties){                    //all indexs should be sorted now by max.x but can later be sorted by anything                    var layer = {}                    layer.index = i                    layer.shapes = sorter                    layers.push(layer)                  }                  counter++              }          }//end for numlayers          $.writeln("Layers Obj Creation");          //sort our layers object we created          //$.writeln(JSON.stringify(layers[0]))          for(var i = 0; i<layers.length; i++){            var xOffset, yOffset;            var xMax,yMax;            var width, height;            var xSortArray = layers[i].shapes.slice(0)            var ySortArray = layers[i].shapes.slice(0)            //var xMaxSortArray = layers[i].shapes.slice(0)            //var yMaxSortArray = layers[i].shapes.slice(0)            xOffset = xSortArray.sort(function(a,b){return a.min.x-b.min.x})[0].min.x            yOffset = ySortArray.sort(function(a,b){return a.min.y-b.min.y})[0].min.y            xMax = xSortArray.sort(function(a,b){return b.max.x-a.max.x})[0].max.x            yMax = xSortArray.sort(function(a,b){return b.max.y-a.max.y})[0].max.y            //xMaxSortArray.sort()            $.writeln("xOffset: "+xOffset+" yOffset "+yOffset)            //$.writeln( "XMIN min: "+xSortArray[0].min.x+" max: "+ xSortArray[xSortArray.length-1].min.x)            //$.writeln( "YMIN min: "+ySortArray[0].min.y+" max: "+ ySortArray[xSortArray.length-1].min.y)            //make global coordinates            layers[i].row = returnCurrentRow(layers[i].index)            var layerPosition = comp.layer(layers[i].index).property("Position").value            var layerAnchor = comp.layer(layers[i].index).property("Anchor Point").value            layers[i].bounding = {x: layerPosition[0], y: layerPosition[1], width: xMax - xOffset, height: yMax - yOffset}            layers[i].bounding.vertices = [  [layers[i].bounding.x, layers[i].bounding.y],                                             [layers[i].bounding.x, layers[i].bounding.y+layers[i].bounding.height],                                             [layers[i].bounding.x+layers[i].bounding.width, layers[i].bounding.y],                                             [layers[i].bounding.x+layers[i].bounding.width, layers[i].bounding.y+layers[i].bounding.height ]                                             ]            for(var j = 0; j<layers[i].shapes.length; j++){              layers[i].shapes[j].shape.world_vertices = []              for(var k = 0; k<layers[i].shapes[j].shape.vertices.length; k++){                var point = [0,0]                //calculate the world coordinate by normalizing the vertice to the layers anchor point                //then add the position of the layer in the composition                point[0] = layers[i].shapes[j].shape.vertices[k][0] - layerAnchor[0] + layerPosition[0]                point[1] = layers[i].shapes[j].shape.vertices[k][1] - layerAnchor[1] + layerPosition[1]                layers[i].shapes[j].shape.world_vertices.push(point)              }            }          }//end layers.length          $.writeln(JSON.stringify(layers[layers.length-1]))          //what we're searching for          //var location = [150,100]          var location = [1120,260]//[1930,260]//[1530,820] //[670,170]          var home    = [1570,450]          $.writeln("Getting Line Between Points")          var line = returnLine(location[0],location[1],home[0],home[1])          $.writeln("Line Length: "+line.length)          var activeRows = [],              activeLayers = [],              activeRibs = [],              lastActiveRib= 0,              lastActiveRow= 0,              lastActiveLayer = 0          for(var m =0; m<line.length; m++ ){            for(var i = 0; i<layers.length;i++){              //check if line passes through layer              if( isInside( line[m][0],line[m][1], layers[i].bounding.vertices ) )                if( activeLayers.indexOf(layers[i].index) == -1 ) activeLayers.push(layers[i].index)            }          }          $.write("Active Layers: ")          $.writeln(activeLayers.length)          $.writeln(activeLayers)          //iterate through the active layers for indexs of active ribs          for(var i = 0; i<activeLayers.length; i++){            var currentLayer = null            for(var j =0; j<layers.length; j++){              if(layers[j].index == activeLayers[i] ){                currentLayer =layers[j]                $.writeln("Found Current Layer: "+currentLayer.index)                break              }            }            var activeCurrently= []            for(var j =0; j<currentLayer.shapes.length; j++){              var bInside = false              //get the lowest and highest              //and light the rest up              //active this row              for(var m = 0; m<line.length; m++){                if(isInside( line[m][0],line[m][1], currentLayer.shapes[j].shape.world_vertices)){                  $.writeln(JSON.stringify({layer: currentLayer.index, index: currentLayer.shapes[j].index }))                  activeRibs.push({layer: currentLayer.index, index: currentLayer.shapes[j].index })                  maskOpacity(currentLayer.index,currentLayer.shapes[j].index ,100)                  bInside = true                  if(  activeCurrently.indexOf(currentLayer.shapes[j].index) == -1){                    activeCurrently.push( currentLayer.shapes[j].index )                  }                  break                }              }            }            //$.write("activeCurrently:  ")            //$.writeln(activeCurrently)          }          //set world coordinates          //array of json objects          //{ vertices:  layer: , index:, bounding:{x,y,width,height} }          /*          var polys = []          //what we're searching for          var location = [150,100]          var home    = [1500,480]          $.writeln("Getting Line Between Points")          var line = returnLine(location[0],location[1],home[0],home[1])          $.writeln("Line Length: "+line.length)          var hits = []          $.writeln("Finding Active Masks")          var activeRows =[]          var lastActiveRow = 0          var stopSearch = false          //endSearch:            for(var m =0; m<line.length; m++ ){             //if(stopSearch = true) break;             var lastRowThisLoop=0;             for(var l = 0; l<polys.length; l++){                currentRow = returnCurrentRow(polys[l].layer)                if(isInside(line[m][0],line[m][1], polys[l].vertices)){                  $.writeln("currentRow: "+currentRow+" inside "+polys[l].layer+" mask: "+ polys[l].index)                  //$.writeln(shape.vertices)                  //maskOpacity(polys[l].layer,polys[l].index,100)                  lastRowThisPoly    = currentRow                  if(activeRows.indexOf(currentRow)==-1) activeRows.push(currentRow)                  hits.push(polys[l])                }else{                  maskOpacity(polys[l].layer,polys[l].index,0)                }             }           }         $.writeln("ended search")         $.writeln("active rows "+activeRows.length)         $.writeln(activeRows)         $.writeln("Found: "+hits.length+" Items")         $.writeln("Starting Sort.")         //var activeLayers=[]         //sort hits and decide which rows to connect where.         for(var h = 0; h< hits.length; h++){          //  for(var r = 0; r< layersByRow.length; r++){          //    if(layersByRow[r].indexOf(hits[h].layer)>-1){          //      $.writeln("Row: "+r)          //      if(activeRows.indexOf(r)==-1) activeRows.push(r)          //      break;          //    }           //          //  }           maskOpacity(hits[h].layer,hits[h].index,100)         }         //begin creating paths         $.writeln("Sort Completed")*/    }// if(comp !=null)/*********** HELPER FUNCTIONS*********/function maskOpacity(layer,index,value){         comp.layer(layer).property("ADBE Mask Parade").property(index).property("Mask Opacity").expression=""         comp.layer(layer).property("ADBE Mask Parade").property(index).property("Mask Opacity").setValue(value)                    }function AEHelper(_type){        //set up our vars        var type =_type        //varialize our methods        this.setup = function(){                for(var i =1; i<=app.project.numItems; i++){                    if(app.project.items[i].typeName === type )                        this.add(app.project.items[i])                }            }        //Array for Project Items        this.all = [];        this.length= function(){ return this.all.length }        // Push Custom Item into Compositions Collection        this.add = function(_CustomItem){            this.all.push(_CustomItem)        }        this.byName=function(name){            //name exists            for(var i =0; i< this.all.length; i++) if(this.all[i].name === name) return this.all[i]            //name doesn't exist            return null;        }        //run setup on creation        this.setup()    }/* MATH */function returnMax(vertices,which){     //which 0 or 1 x or y    var max =vertices[0][which]    for(var k = 1; k < vertices.length; k++){            if(max < vertices[k][which]) max = vertices[k][which]    }    return max    }function returnMin(vertices,which){        var min = vertices[0][which];        for(var k= 1; k<vertices.length;k++){                if(min > vertices[k][which]) min = vertices[k][which]            }        return min    }function returnOpacityExpression(counter){  var exp = "linear(time,thisLayer.inPoint,thisLayer.inPoint+"+counter+",0,100)";  var exp = "start = thisLayer.inPoint +"+(counter/10)+";"  exp+= "end = thisLayer.inPoint +"+(counter/10)+"+ 0.3;"  exp+= " linear(time,start,end,0,100);"  exp+= "if(time>end){linear(time,end+0.5,end+0.5,100,0)};"  return exp}function isInside(x,y,vertices){  var N = vertices.length,      p1,p2,      counter =0,      i,      xinters      p1 = vertices[0]      for( i = 1;i<=N;i++){        p2= vertices[i%N]        if(y> Math.min(p1[1], p2[1])){          if (y <= Math.max(p1[1],p2[1])) {                if (x <= Math.max(p1[0],p2[0])) {                    if (p1[1] != p2[1]) {                        xinters = (y-p1[1])*(p2[0]-p1[0])/(p2[1]-p1[1])+p1[0];                        if (p1[0] == p2[0] || x <= xinters)                            counter++;                    }                }            }        }        p1 = p2      }     if (counter % 2 == 0) return false;	  else return true;}function returnCurrentLayer(index){  for(var j =0; j<layers.length; j++){    if(layers[i].index == activeLayers[i] )      return layers[i]  }  return -1}function returnCurrentRow(layer){  for(var r = 0; r < layersByRow.length; r++)      if(layersByRow[r].indexOf(layer)>-1)        return r    return -1}//http://tech-algorithm.com/articles/drawing-line-using-bresenham-algorithm/function returnLine( x, y, x2,  y2) {    var line =[]    line.push([x,y])    var w = x2 - x ;    var h = y2 - y ;    var dx1 = 0, dy1 = 0, dx2 = 0, dy2 = 0 ;    if (w<0) dx1 = -1 ; else if (w>0) dx1 = 1 ;    if (h<0) dy1 = -1 ; else if (h>0) dy1 = 1 ;    if (w<0) dx2 = -1 ; else if (w>0) dx2 = 1 ;    var longest = Math.abs(w) ;    var shortest = Math.abs(h) ;    if (!(longest>shortest)) {        longest = Math.abs(h) ;        shortest = Math.abs(w) ;        if (h<0) dy2 = -1 ; else if (h>0) dy2 = 1 ;        dx2 = 0 ;    }    var numerator = longest >> 1 ;    for (var i=0;i<=longest;i++) {        //putpixel(x,y,color) ;        /*if( i%5==0 )*/ line.push([x,y])        numerator += shortest ;        if (!(numerator<longest)) {            numerator -= longest ;            x += dx1 ;            y += dy1 ;        } else {            x += dx2 ;            y += dy2 ;        }    }    line.push([x2,y2])    return line}