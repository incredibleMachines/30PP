ï»¿//include our global functions/ helpers#include '30_PP_Globals.jsx';#include 'createVertexPath.jsx';function main(opts){     var console = new Console();     app.beginSuppressDialogs();  //suppress dialogs from AE     //$.writeln("Starting "+opts.type)    //$.writeln(JSON.stringify(opts.data))    //handle aep project    closeCurrentProject();    openProject(opts.template);    var project = app.project;    //setup our comps    var comps = new AEHelper("Composition");    comps.setup(project)    //$.writeln(comps.all)    //create a new Object with our Composition Names    var newData = {};    //iterate through each of our data objects to create the composition structure    for(var key in opts.data){                //$.writeln(key)                //handle location and multitext different than the others because they are                if( key.indexOf("multi_location")>=0 || key.indexOf("multitext") >=0){		            for(var i =0;i<opts.data[key].length;i++){		            	//console.log(opts.data[key].length)		                if(opts.data[key][i].length>1 && key.indexOf('multi_location')>=0 ){			                var newKey = 'source_multi_location';			                newData[newKey] = opts.data[key][i]		                }else{			                for(var j =0; j<opts.data[key][i].length;j++){			                        var newKey = key+"_"+i+"_"+j;			                        var text			                        if(newKey.indexOf("text")>=0){ text = opts.data[key][i][j].replace("&quot;","'")			                        } else text = opts.data[key][i][j]			                        newData[newKey] =text;							}						}		            }                }else{                    for(var i =0; i<opts.data[key].length;i++){                        var newKey = key+"_"+i;                        var text = opts.data[key][i]                        //if(newKey.indexOf("text")>=0) text = text.replace("&quot;","'")                        //else text = opts.data[key][i]                        newData[newKey] = text//opts.data[key][i]                        }                }    }    //console.log("NEWDATA")    //console.log(JSON.stringify(newData))    //$.writeln(JSON.stringify(newData))    //console.log("test")    var TextRects = [];    var counter = -1;    var multiTextCounter = 0;    for(var key in newData){            if(key.indexOf("multitext")>=0){                var selectedComp = comps.byName(key);                //alert(key)                if(selectedComp){                    $.writeln("Found Comp: "+key)                    if(key.indexOf('text')>=0){                        //$.writeln(newData[key])                        //multitext                         selectedComp.layer(1).property("Source Text").setValue(newData[key])                         //change the                         var modifier = selectedComp.layer(1).property("Source Text").value                         modifier.justification = ParagraphJustification.LEFT_JUSTIFY                         modifier.fontSize = MULTITEXT.font_size //50                         selectedComp.layer(1).property("Source Text").setValue(modifier)                         //check for highlight state                         //var highlight = false;                        //console.log("multitext")                        //console.log(newData[key])                        //var check = newData[key].replace("'","&quot;")                        //highlight = (opts.data.source_sequence_text_L.indexOf(check) === -1 && opts.data.source_sequence_text_R.indexOf(check) === -1)? false : true;                        //if(highlight==false){                           //check the position and set highlight                          //if(multiTextCounter % 5 == 0) highlight = true                        //}                        //selectedComp.layer(1).effect(1).enabled = highlight;                         //var textRect = selectedComp.layer(1).sourceRectAtTime(0, false);                         //var t = {}                         //t[key]=textRect                         //t[key].top = Math.ceil(t[key].top)                         //t[key].left = Math.ceil(t[key].left)                         //t[key].width = Math.ceil(t[key].width)                         //t[key].height = Math.ceil(t[key].height)                         //TextRects.push(t)                         //alert(textRect.top + " " + textRect.left + " " + textRect.width + " " + textRect.height);                         //$.writeln(Math.ceil(textRect.width))                        // multiTextCounter++;                   }               }           }           if(key === "source_multi_location"){	           var multiLocComp = comps.byName(key)	           if(multiLocComp){	           	//console.log("Has KEY "+key)	           	if(multiLocComp.numLayers>1){	           		//console.log("DELETING LAYERS")	           		//console.log(multiLocComp.numLayers)					for(var i = multiLocComp.numLayers; i>1;i--){						//console.log("DELETING LAYER "+i)						//remove all old multilocations from comp						multiLocComp.layer(i).remove()					}//endfor				}//end if(multiLocComp.numLayers>1)				for(var i = 2; i<=newData[key].length; i++){					//console.log("MAKING NEW LAYER")					//compy layer one back into the composition					multiLocComp.layer(1).copyToComp(multiLocComp)				}				for(var i = 1; i<=newData[key].length; i++){					//Update each layers position property					//TO DO: map x and y					//map value from 512 range to 2048					var holder = [newData[key][i-1].x*LOCATION.size_diff,newData[key][i-1].y*LOCATION.size_diff,0]					multiLocComp.layer(i).property("Position").setValue(holder)          multiLocComp.layer(i).startTime = Math.random()*1.5				}	          }//end if(multiLocComp)           }//end if(key==="source_multi_location")     }//endfor(key in newData)     //loop through multitext and set pos     var multiTextComp = comps.byName('multitext_row');     if(multiTextComp){   		//console.log("Comp Width:"+ multiTextComp.width)   		var default_space = MULTITEXT.text_space//150;//amount of space between texts   		var current_pos = 0;   		var last_pos = 0;   		var max_width = MULTITEXT.max_width//30000   		for(var i = 0; i<TextRects.length;i++){       		for(var key in TextRects[i] ){  	     		var comp = comps.byName(key);  				   //console.log(comp.layer(1).property("Source Text").value.text)  				   //console.log(i+" : "+key+" : "+JSON.stringify(TextRects[i][key]))  	     		//printItemInfo(multiTextComp.layer(i+1))  	     		var layerNum = parseInt(i)+1;  	     		if( layerNum <= multiTextComp.numLayers){  	     			//console.log("Layer: "+layerNum+" Index: "+i)  	     			//set our anchor position               var anchor = [0, multiTextComp.layer(layerNum).height/2]  	     			multiTextComp.layer(layerNum).property("Anchor Point").setValue(anchor)  	     			//calculate the position  	     			var y = multiTextComp.layer(layerNum).property("Position").value[1]  	     			//setup our x pos - if its the first layer then default  	     			var x = (i>0)? current_pos+default_space : (default_space/2)               current_pos = x+TextRects[i][key].width               //console.log("Current Pos:")               //console.log(current_pos)  	     			if(current_pos+(default_space/2) < max_width) last_pos = current_pos  	     			var pos = [x,y,0]  	     			multiTextComp.layer(layerNum).property("Position").setValue(pos)               multiTextComp.layer(layerNum).enabled = true             if(layerNum == TextRects.length /*multiTextComp.numLayers*/){  	     				var newWidth = last_pos+(default_space/2)                 //console.log("newWidth: ")                 //console.log(newWidth)  		     			multiTextComp.width = (newWidth < max_width)? newWidth: max_width  	     			}  	     		}       		}//end for(var key in TextRects[i]   		}//end for(var i =0; i<TextRects.length;i++)       if(multiTextComp.numLayers > TextRects.length){         for(var i = TextRects.length+1; i<=multiTextComp.numLayers;i++){           multiTextComp.layer(i).enabled = false         }       }//end if(multiTextComp.numLayers > TextRects.length)     }//end if(multiTextComp)     //sequence text and images     //support for locations as well.     for(var key in newData){	     if(key.indexOf('sequence')>=0){		     //modify sequence text		     var selectedComp = comps.byName(key);		     //console.log(key)		     //console.log(typeof selectedComp)		     if(selectedComp){			    if(key.indexOf('image') >= 0 ){			    	//console.log("image")			    	//console.log(opts.asset_loc+newData[key])			    	var file_loc = opts.asset_loc+newData[key]            selectedComp.layer(1).source.replace(new File(file_loc))          }else if(key.indexOf('text')>=0){            //console.log("text")            //console.log(newData[key])            //check the width of the object            var text = newData[key].replace("&quot;","'")            selectedComp.layer(1).property("Source Text").setValue(text)            if(key.indexOf('0')==-1){              var temp = key.replace('R','S')              var next = comps.byName(temp)              next.layer(1).property("Source Text").setValue(text)            }            //check for setting the item yellow            //var highlight = false;            //selectedComp.layer(1).effect(1).enabled = highlight;            //app.project(index).layer(index).propertySpec            //console.log("THIS SEQTEXT: "+text)            //var textDoc = selectedComp.layer(1).property("Source Text").value            //do a check for the length of the source text          }		     }	     }else if(key.indexOf('source_single_location')>=0){		     //process single loc		     //console.log('single_loc')		     //console.log(key)		  	var singleLocComp = comps.byName(key)		  	if(singleLocComp){			  	//console.log("single location exists")			  	//modify mask with array grid			  	var path = []			  	// for(var i = 0; i<newData[key].directions.length; i++){				  // 	path.push([newData[key].directions[i][0]*LOCATION.size_diff,newData[key].directions[i][1]*LOCATION.size_diff])			  	// }			  	//if(path.length>0){			  		// var pathShape = new Shape()			  		// pathShape.vertices = path			  		// pathShape.closed = false            //create new mapping value for item            var pathShape = createVertexPath([newData[key].directions[newData[key].directions.length-1][0]*LOCATION.size_diff,newData[key].directions[newData[key].directions.length-1][1]*LOCATION.size_diff])            $.writeln(pathShape.vertices)            var holder = [newData[key].pos.x*LOCATION.size_diff,newData[key].pos.y*LOCATION.size_diff,0]            //var holder = [pathShape.vertices[0][0],pathShape.vertices[0][1],0]			  	  singleLocComp.layer(1).property("Position").setValue(holder)			  		//singleLocComp.layer(1).property("ADBE Mask Parade").property(1).property("ADBE Mask Shape").setValue(pathShape);			  	//}		  	}	     }     }//end for     //render content     //process content for render     clearRenderQueue();     var UV_OUT = comps.byName('UV_OUT')     if(UV_OUT){	     //app.project.renderQueue.items.add(UV_OUT.item);	     //var renderObject = app.project.renderQueue.item(1);         //renderObject.outputModule(1).file = new File(opts.output)         //will not actually render file here         //make all changes and then render         //-compapp.project.renderQueue.render()     }else{	     //console.log('no UV_OUT')	     return false     }    //$.writeln("Completing "+opts.type)    closeCurrentProject(true);    return true;}