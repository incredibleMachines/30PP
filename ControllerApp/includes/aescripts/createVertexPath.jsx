/* Incredible Machines 2014 	cpiuggi 05/27/14  *///create a VertexPath off the sculpture Masks//pass a location value of in the form of an array [x,y]//#include '30_PP_Globals.jsx';function createVertexPath(location){  //the point of 30PP  var home    = [1570,450]  var project = app.project;  var compositions =  new AEHelper("Composition")  var sculpt = compositions.byName("pathfinder_Sculpt_Fill")  var ribs = compositions.byName("pathfinder_Ribs")  //necessary functions for this  var ribsByRow =[]  if(ribs!=null){    //$.write("Ribs Comp Found - Num Layers: ")    //$.writeln(" "+ribs.numLayers)    for(var i = 1;i <=ribs.numLayers; i++){      var layerMask = ribs.layer(i).property("ADBE Mask Parade")      for(var j = 1; j<=layerMask.numProperties ; j++){        var shape = layerMask.property(j).property("ADBE Mask Shape").value        var obj = {}        obj.vertices = shape.vertices        obj.inTangents= shape.inTangents        obj.outTangents= shape.outTangents        obj.closed = shape.closed        ribsByRow.push(obj)      }    }  }  //$.writeln("Found Ribs: "+ribsByRow.length)  //for(var i = 0; i< ribsByRow.length;i++){    //$.writeln(i+" "+JSON.stringify(ribsByRow[i]))  //}  //$.writeln(JSON.stringify(ribsByRow))  //var location = [1530,820]//[1120,260]//[1440,730]//[1930,260] //[670,170]  //make this contain vertices, inTangents, outTangents, closed:false,  var pathToDestination = {}      pathToDestination.vertices = []      pathToDestination.inTangents = []      pathToDestination.outTangents = []      pathToDestination.closed = false      // pathToDestination.vertices.push(home)      // pathToDestination.inTangents.push([0,0])      // pathToDestination.outTangents.push([0,0])  //left to right  var layersByRow = [              [1,2,3,4],              [5,6,7,8],              [9,10,11,12],              [13,14,15,16],              [17,18,19],              [20,21,22],              [23,24],              [25,26,27],              [28,29]     ]  //array of layer objects containing all the masks in the shapes groups  var layers =[]  if(sculpt != null){          //$.write("Sorting Comps...")          //$.writeln(comp.numLayers)          for(var i = 1; i<= sculpt.numLayers;i++){            //iterate through the masks            var layerMask = sculpt.layer(i).property("ADBE Mask Parade")            //$.writeln("Layer Index: "+i+" | NUM Masks: "+layerMask.numProperties)            //set up all our masks for each layer            var counter = 1;            //run through all of the layerMask Properties with a custom counter            while(counter <= layerMask.numProperties){                    var sorter = []                    //create an array to sort the items by value                    //iterate through each and get the max vertices for each X                    for(var j = layerMask.numProperties; j>0 ; j--){                        var shape = layerMask.property(j).property("ADBE Mask Shape").value                        var max = { x: returnMax(shape.vertices,0), y: returnMax(shape.vertices,1)}                        if(counter == layerMask.numProperties) var min = { x: returnMin(shape.vertices,0), y: returnMin(shape.vertices,1)}                        var obj = {}                        obj.index = j                        obj.max = max                        if(counter == layerMask.numProperties){                          obj.min = min                          obj.shape = JSON.parse(JSON.stringify(shape))                          delete obj.shape.featherInterps                          delete obj.shape.featherRadii                          delete obj.shape.featherRelCornerAngles                          delete obj.shape.featherRelSegLocs                          delete obj.shape.featherSegLocs                          delete obj.shape.featherTensions                          delete obj.shape.featherTypes                         }                        sorter.push(obj)                    }                    //sort the array highest to lowest                    sorter.sort(function(a,b){return  b.max.x-a.max.x})                    //reverse them                    sorter.reverse()                    //$.writeln(JSON.stringify(sorter))                    layerMask.property(sorter[counter-1].index).moveTo(counter)                    //set the mask opacity to have a linear expression                    //layerMask.property(counter).property("Mask Opacity").expression = returnOpacityExpression(counter);                    maskOpacity(sculpt,i,counter,100)                    if(counter == layerMask.numProperties){                      //all indexs should be sorted now by max.x but can later be sorted by anything                      var layer = {}                      layer.index = i                      layer.shapes = sorter                      layers.push(layer)                    }                    counter++                }            }//end for numlayers            //$.writeln("  Sort Completed.")            //$.write("Creating Layers Obj...");            //sort our layers object we created            //$.writeln(JSON.stringify(layers[0]))            for(var i = 0; i<layers.length; i++){              var xOffset, yOffset;              var xMax,yMax;              var width, height;              var xSortArray = layers[i].shapes.slice(0)              var ySortArray = layers[i].shapes.slice(0)              //var xMaxSortArray = layers[i].shapes.slice(0)              //var yMaxSortArray = layers[i].shapes.slice(0)              xOffset = xSortArray.sort(function(a,b){return a.min.x-b.min.x})[0].min.x              yOffset = ySortArray.sort(function(a,b){return a.min.y-b.min.y})[0].min.y              xMax = xSortArray.sort(function(a,b){return b.max.x-a.max.x})[0].max.x              yMax = xSortArray.sort(function(a,b){return b.max.y-a.max.y})[0].max.y              //xMaxSortArray.sort()              //$.writeln("xOffset: "+xOffset+" yOffset "+yOffset)              //$.writeln( "XMIN min: "+xSortArray[0].min.x+" max: "+ xSortArray[xSortArray.length-1].min.x)              //$.writeln( "YMIN min: "+ySortArray[0].min.y+" max: "+ ySortArray[xSortArray.length-1].min.y)              //make global coordinates              layers[i].row = returnCurrentRow(layersByRow,layers[i].index)              var layerPosition = sculpt.layer(layers[i].index).property("Position").value              var layerAnchor = sculpt.layer(layers[i].index).property("Anchor Point").value              layers[i].bounding = {x: layerPosition[0], y: layerPosition[1], width: xMax - xOffset, height: yMax - yOffset}              layers[i].bounding.vertices = [  [layers[i].bounding.x, layers[i].bounding.y],                                               [layers[i].bounding.x, layers[i].bounding.y+layers[i].bounding.height],                                               [layers[i].bounding.x+layers[i].bounding.width, layers[i].bounding.y],                                               [layers[i].bounding.x+layers[i].bounding.width, layers[i].bounding.y+layers[i].bounding.height ]                                               ]              for(var j = 0; j<layers[i].shapes.length; j++){                layers[i].shapes[j].shape.world_vertices = []                //$.writeln("Shape Length: "+layers[i].shapes[j].shape.vertices.length)                for(var k = 0; k<layers[i].shapes[j].shape.vertices.length; k++){                  var point = [0,0]                  //calculate the world coordinate by normalizing the vertice to the layers anchor point                  //then add the position of the layer in the composition                  point[0] = layers[i].shapes[j].shape.vertices[k][0] - layerAnchor[0] + layerPosition[0]                  point[1] = layers[i].shapes[j].shape.vertices[k][1] - layerAnchor[1] + layerPosition[1]                  layers[i].shapes[j].shape.world_vertices.push(point)                }              }            }//end layers.length            //$.writeln("Layers Objects Created")            //$.writeln(JSON.stringify(layers[layers.length-1]))            //$.writeln("Getting Line Between Points")            var line = returnLine(location[0],location[1],home[0],home[1])            //$.writeln("Line Length: "+line.length)            var activeRows = [],                activeLayers = [],                activeRibs = [],                lastActiveRib= 0,                lastActiveRow= 0,                lastActiveLayer = 0            for(var m =0; m<line.length; m++ ){              for(var i = 0; i<layers.length;i++){                //check if line passes through layer                if( isInside( line[m][0],line[m][1], layers[i].bounding.vertices ) )                  if( activeLayers.indexOf(layers[i].index) == -1 ) activeLayers.push(layers[i].index)              }            }            //$.write("Active Layers: ")            //$.writeln(activeLayers.length)            //$.writeln(activeLayers)            //$.write("Finding Active Ribs: ")            var inactiveRibs = []            //iterate through the active layers for indexs of active ribs            for(var i = 0; i<activeLayers.length; i++){              var currentLayer = returnCurrentLayer(layers,activeLayers[i])              var bActiveRibs = false              //add to active row              if(  activeRows.indexOf(currentLayer.row) == -1) activeRows.push(currentLayer.row)              var activeCurrently= []              for(var j =0; j<currentLayer.shapes.length; j++){                var bInside = false                //get the lowest and highest                //and light the rest up                //active this row                for(var m = 0; m<line.length; m++){                  if(isInside( line[m][0],line[m][1], currentLayer.shapes[j].shape.world_vertices)){                    bActiveRibs = true                    //$.writeln(JSON.stringify({layer: currentLayer.index, index: currentLayer.shapes[j].index }))                    activeRibs.push({layer: currentLayer.index, row: currentLayer.row, index: currentLayer.shapes[j].index })                    //maskOpacity(currentLayer.index,currentLayer.shapes[j].index ,100)                    bInside = true                    if(  activeCurrently.indexOf(currentLayer.shapes[j].index) == -1){                      activeCurrently.push( currentLayer.shapes[j].index )                    }                    break                  }                }              }              if(bActiveRibs == false ) inactiveRibs.push(activeLayers[i])              //$.write("activeCurrently:  ")              //$.writeln(activeCurrently)            }            //$.writeln("  Active Ribs Found.")            if(inactiveRibs.length>0){              //$.writeln(" InActive Layers Found.")              //$.writeln(inactiveRibs)              //$.writeln("Removing Inactive Layers")              for(var i = 0; i<inactiveRibs.length; i++){                activeLayers.splice( activeLayers.indexOf(inactiveRibs[i]),1)              }              //$.writeln("Updated Active Layers")              //$.writeln(activeLayers)            }            //create path            //check all the active layers and determine the active rows            //$.writeln("Active Rows")            //$.writeln(activeRows)            var maxRow = Math.max.apply(Math, activeRows)            //check the direction of the line - up or down, this is done by the max row active.            var minRow = Math.min.apply(Math, activeRows)            //$.writeln("Sorting Active Ribs")            //{layer: currentLayer.index, row: currentLayer.row, index: currentLayer.shapes[j].index }            //sort our active ribs by row, layer and index            var direction = {}            direction.y = (maxRow < 5)?  'down':'up'            direction.x = (home[0]<location[0])?'left':'right'            //$.writeln("Line Direction: "+direction.y+" "+direction.x)            activeRibs.sort(function(a,b){              var row = a.row - b.row              var layer = null,                  _index = null              if(row == 0) layer = a.layer - b.layer              if(row == 0 && (layer == 0 && layer !=null )) _index = a.index - b.index              if(layer == null) layer = 0              if(_index == null) _index  0              if(direction.y == 'up') row *= -1 //flip layers if we're going up              if(direction.x == 'left') _index *= -1 //flip layers if we're going to the left              return row+layer+_index            })            //$.writeln("Completed")            //$.writeln(JSON.stringify(activeRibs))            //set our points to rock now            //don't do the last rib we check the next rib after and get it on the last loop            //$.writeln("Iterating on Ribs")            //get the direction its moving            for(var rib = 0; rib<activeRibs.length-1;rib++){              //$.writeln(activeRibs[rib].layer+ " "+activeRibs[rib].index)              var _ribLayer = returnCurrentLayer(layers,activeRibs[rib].layer)              //var _nextRibLayer = returnCurrentLayer(layers,activeRibs[rib+1].layer)              var _rib = _ribLayer.shapes[activeRibs[rib].index-1]              //$.writeln(_rib.shape.world_vertices)              $.writeln()              //if its the first rib              if(rib == 0 ){                  //$.writeln("World Vertices")                  //$.writeln(_rib.shape.world_vertices)                  //$.writeln("inTangents")                  //$.writeln(_rib.shape.inTangents)                  //$.writeln("outTangents")                  //$.writeln(_rib.shape.outTangents)                  //if we're going up get the lowest y                  //if we're going down get the highest y                  //get the first vertex - 0                  $.writeln("First Point")                  //now get the lowest vertex                  var pointToGet;                  if(direction.y == 'down'){                      pointToGet = returnMaxIndex(_rib.shape.world_vertices,1)                  }else if(direction.y == 'up'){                      pointToGet = returnMinIndex(_rib.shape.world_vertices,1)                  }                  //get the diff between point to get and 0                  //$.writeln("shape vertices Length: "+_rib.shape.world_vertices.length+" Point To Get "+pointToGet)                  if(pointToGet > _rib.shape.world_vertices.length/2){                    for(var i = _rib.shape.world_vertices.length; i>=pointToGet; i--){                      var j = i                      if(i==_rib.shape.world_vertices.length) j = 0                      $.writeln("Pushing into Destination Path")                      pathToDestination.vertices.push(_rib.shape.world_vertices[j])                      //pathToDestination.inTangents.push(_rib.shape.inTangents[i])                      //pathToDestination.outTangents.push(_rib.shape.outTangents[i])                      pathToDestination.outTangents.push(_rib.shape.inTangents[j])                      pathToDestination.inTangents.push(_rib.shape.outTangents[j])                    }                  }else{                    for(var i = -1; i<=pointToGet; i++){                    var j = i                    if(i == -1)j=_rib.shape.world_vertices.length-1                    $.writeln("Pushing into Destination Path")                    pathToDestination.vertices.push(_rib.shape.world_vertices[j])                    pathToDestination.inTangents.push(_rib.shape.inTangents[j])                    pathToDestination.outTangents.push(_rib.shape.outTangents[j])                  }                  }                  //$.writeln(JSON.stringify(_ribLayer))                  //var _ribIndex              }else if(rib == activeRibs.length-2){                  //the last Rib                  var pointToGet;                  var _nextRibLayer = returnCurrentLayer(layers,activeRibs[rib+1].layer)                  var _nextRib = _nextRibLayer.shapes[activeRibs[rib+1].index-1]                  if(direction.y == 'down') {                      pointToGet = returnMaxIndex(_nextRib.shape.world_vertices,1)                  }else if(direction.y =='up'){                      pointToGet = returnMinIndex(_nextRib.shape.world_vertices,1)                  }                  $.writeln("Pushing into Destination Path")                  $.writeln("LAST POINT")                  //$.writeln(JSON.stringify(_nextRib.shape.world_vertices[pointToGet]))                  //$.writeln(JSON.stringify(_nextRib.shape.world_vertices[pointToGet-1]))                  pathToDestination.vertices.push(_nextRib.shape.world_vertices[pointToGet])                  pathToDestination.inTangents.push(_nextRib.shape.inTangents[pointToGet])                  pathToDestination.outTangents.push(_nextRib.shape.outTangents[pointToGet])                  break              }              if(activeRibs[rib+1].layer == activeRibs[rib].layer){                //check if theres a break in the width via the indexs                //$.writeln("Same Layer")                  var currentRow, pointToGet                  if(direction.y == 'down') {                      pointToGet = returnMaxIndex(_rib.shape.world_vertices,1)                      currentRow = activeRibs[rib].row                  }else if(direction.y =='up'){                      pointToGet = returnMinIndex(_rib.shape.world_vertices,1)                      currentRow = activeRibs[rib].row-1                  }                // $.write("Current Row: ")                // $.writeln(currentRow)                //                // $.write("ribsByRow Length:  ")                // $.writeln(ribsByRow.length)                for(var rb = 0; rb<ribsByRow[currentRow].vertices.length;rb++){                    // $.write("RibsByRow["+activeRibs[rib].row+"].vertices["+rb+"][0] :: ")                    // $.writeln(ribsByRow[activeRibs[rib].row].vertices[rb][0])                    // $.write("pathToDestination.vertices["+pathToDestination.vertices.length-1+"][0] :: ")                    // $.writeln(pathToDestination.vertices[pathToDestination.vertices.length-1][0])                    // $.write("_rib.shape.world_vertices["+pointToGet+"][0] :: ")                    // $.writeln(_rib.shape.world_vertices[pointToGet][0])                    if( (ribsByRow[currentRow].vertices[rb][0] < pathToDestination.vertices[pathToDestination.vertices.length-1][0] &&                         ribsByRow[currentRow].vertices[rb][0] > _rib.shape.world_vertices[pointToGet][0])  ||                        (ribsByRow[currentRow].vertices[rb][0] > pathToDestination.vertices[pathToDestination.vertices.length-1][0] &&                         ribsByRow[currentRow].vertices[rb][0] < _rib.shape.world_vertices[pointToGet][0] )                    ){                      //$.writeln("Rib Crossed")                      //$.writeln("Pushing into Destination Path")                      pathToDestination.vertices.push(ribsByRow[currentRow].vertices[rb])                      pathToDestination.inTangents.push([0,0])                      pathToDestination.outTangents.push([0,0])                    }                  }                //$.writeln("Current Layer: "+activeRibs[rib].layer+" next: "+activeRibs[rib+1].index+" current: "+activeRibs[rib].index+" Length: "+_ribLayer.shapes.length+"")                /*if( ( activeRibs[currentRow].index >= _ribLayer.shapes.length/2 && activeRibs[currentRow].index <= _ribLayer.shapes.length/2) ||                    ( activeRibs[currentRow].index <= _ribLayer.shapes.length/2 && activeRibs[currentRow].index >= _ribLayer.shapes.length/2)){*/                //base of rib and next rib                var _nextRibLayer = returnCurrentLayer(layers,activeRibs[rib+1].layer)                var _nextRib = _nextRibLayer.shapes[activeRibs[rib+1].index-1]                var pointToGet1, pointToGet2;                if(direction.x ==  'left'){                  pointToGet1 = returnMinIndex(_rib.shape.world_vertices,0)                  pointToGet2 = returnMinIndex(_nextRib.shape.world_vertices,0)                }else if(direction.x == 'right'){                  pointToGet1 = returnMaxIndex(_rib.shape.world_vertices,0)                  pointToGet2 = returnMaxIndex(_nextRib.shape.world_vertices,0)                }                if( ( _rib.shape.world_vertices[pointToGet1] >= (_ribLayer.bounding.width/2+_ribLayer.bounding.x) && _nextRib.shape.world_vertices[pointToGet2] <= (_ribLayer.bounding.width/2+_ribLayer.bounding.x) ) ||                    ( _rib.shape.world_vertices[pointToGet1] <= (_ribLayer.bounding.width/2+_ribLayer.bounding.x) && _nextRib.shape.world_vertices[pointToGet2] >= (_ribLayer.bounding.width/2+_ribLayer.bounding.x) )){                      // if(activeRibs[rib].row<4){                      //                      // }                      //find the middle point.                      var vertIndex=-1                      for(var ly = 0; ly< layersByRow.length; ly++){                        var idx = layersByRow[ly].indexOf(activeRibs[rib].layer)                        if(idx != -1){                          vertIndex = idx                          break                        }                          vertIndex= -1                      }                      //$.writeln("Need Middle Point")                      //$.write("Ribs By Row: ")                      //$.writeln(JSON.stringify(ribsByRow[activeRibs[rib].row-1]))                      //$.writeln(ribsByRow[activeRibs[rib].row-1].vertices[vertIndex*2-1])                      //$.writeln("idx "+vertIndex)                      //$.writeln(activeRibs[rib].layer)                      //$.writeln("Pushing into Destination Path")                      var currentRow                        if(direction.y == 'up'){                          currentRow = activeRibs[rib].row-1                        }else{                          currentRow = activeRibs[rib].row                        }                      pathToDestination.vertices.push(ribsByRow[currentRow].vertices[vertIndex*2])                      pathToDestination.inTangents.push(ribsByRow[currentRow].inTangents[vertIndex*2])                      pathToDestination.outTangents.push(ribsByRow[currentRow].outTangents[vertIndex*2])                    }              }else{                var currentRow                  if(direction.y == 'up'){                    currentRow = activeRibs[rib].row-1                  }else{                    currentRow = activeRibs[rib].row                  }                if(activeRibs[rib+1].row == activeRibs[rib].row){                     //$.writeln("New Layer Same Row : ")                      var vertIndex=-1                      for(var ly = 0; ly< layersByRow.length; ly++){                      var idx = layersByRow[ly].indexOf(activeRibs[rib].layer)                      if(idx != -1){                        vertIndex = idx                        break                      }                        vertIndex= -1                      }                      //$.write("Ribs By Row: ")                      //$.writeln(JSON.stringify(ribsByRow[activeRibs[rib].row-1]))                      //$.writeln(ribsByRow[activeRibs[rib].row-1].vertices[vertIndex*2-1])                      //$.writeln("idx "+vertIndex+" calculated: ")                      //$.writeln(activeRibs[rib].layer)                      //$.writeln("row: "+currentRow)                      //$.writeln("Pushing into Destination Path")                      //check which point is closer?                      var fnlIDX;                      if(direction.x == 'right'){                        fnlIDX = vertIndex*2+2                      }else if(direction.x =='left'){                        fnlIDX = vertIndex*2+1                      }                      var dist1 = Math.abs(pathToDestination.vertices[pathToDestination.vertices.length-1][0] - ribsByRow[currentRow].vertices[vertIndex*2+1][0] )                      var dist2 = Math.abs(pathToDestination.vertices[pathToDestination.vertices.length-1][0] - ribsByRow[currentRow].vertices[vertIndex*2+2][0] )                      var min = Math.min(dist1,dist2)                      if(min == dist1){                        fnlIDX = vertIndex*2+1                      }else{                        fnlIDX = vertIndex*2+2                      }                      //if( ribsByRow[currentRow].vertices[vertIndex*2+1][0] > pathToDestination.vertices[pathToDestination.vertices.length-1][0]                      //var distTwo = ribsByRow[currentRow].vertices[vertIndex*2+2]                      pathToDestination.vertices.push(ribsByRow[currentRow].vertices[fnlIDX])                      pathToDestination.inTangents.push(ribsByRow[currentRow].inTangents[fnlIDX])                      pathToDestination.outTangents.push(ribsByRow[currentRow].outTangents[fnlIDX])                }else{                  //$.writeln("New Row")                  //$.writeln("_ribLayer"+ JSON.stringify(_ribLayer))                  //$.writeln("index: "+activeRibs[rib].index)                  //var min = Math.min(activeRibs[rib+1].row,activeRibs[rib].row)                  //move up or down to a new row                  var pointToGet;                      if(direction.y == 'down' ){                          pointToGet = returnMaxIndex(_rib.shape.world_vertices,1)                      }else if(direction.y =='up'){                          pointToGet = returnMinIndex(_rib.shape.world_vertices,1)                      }                  //check if section is crossing over rib point                  //check last point in path with current point to get                  var vertIndex=-1                      for(var ly = 0; ly< layersByRow.length; ly++){                      var idx = layersByRow[ly].indexOf(activeRibs[rib].layer)                      if(idx != -1){                        vertIndex = idx                        break                      }                        vertIndex= -1                      }                  //$.writeln("checking Rib Crossing")                  for(var rb = 0; rb<ribsByRow[currentRow].vertices.length;rb++){                    // $.write("RibsByRow["+activeRibs[rib].row+"].vertices["+rb+"][0] :: ")                    // $.writeln(ribsByRow[activeRibs[rib].row].vertices[rb][0])                    // $.write("pathToDestination.vertices["+pathToDestination.vertices.length-1+"][0] :: ")                    // $.writeln(pathToDestination.vertices[pathToDestination.vertices.length-1][0])                    // $.write("_rib.shape.world_vertices["+pointToGet+"][0] :: ")                    // $.writeln(_rib.shape.world_vertices[pointToGet][0])                    if( (ribsByRow[currentRow].vertices[rb][0] < pathToDestination.vertices[pathToDestination.vertices.length-1][0] &&                         ribsByRow[currentRow].vertices[rb][0] > _rib.shape.world_vertices[pointToGet][0]) && direction.x == 'right'||                        (ribsByRow[currentRow].vertices[rb][0] > pathToDestination.vertices[pathToDestination.vertices.length-1][0] &&                         ribsByRow[currentRow].vertices[rb][0] < _rib.shape.world_vertices[pointToGet][0] && direction.x == 'left')                    ){                      //$.writeln("Rib Crossed")                      //$.writeln("Pushing into Destination Path")                      pathToDestination.vertices.push(ribsByRow[currentRow].vertices[rb])                      pathToDestination.inTangents.push([0,0])                      pathToDestination.outTangents.push([0,0])                    }                  }                  //$.writeln("rib crossing check complete")                  //$.writeln("Pushing into Destination Path")                  pathToDestination.vertices.push(_rib.shape.world_vertices[pointToGet])                  pathToDestination.inTangents.push(_rib.shape.inTangents[pointToGet])                  pathToDestination.outTangents.push(_rib.shape.outTangents[pointToGet])                  var _nextRibLayer = returnCurrentLayer(layers,activeRibs[rib+1].layer)                  var _nextRib = _nextRibLayer.shapes[activeRibs[rib+1].index-1]                  var pointToGetMin, pointToGetMax                  if(direction.y == 'down' ){                          //these are switched on purpose                          pointToGetMin = returnMinIndex(_nextRib.shape.world_vertices,1)                          pointToGetMax = returnMaxIndex(_nextRib.shape.world_vertices,1)                      }else if(direction.y =='up'){                          pointToGetMax = returnMinIndex(_nextRib.shape.world_vertices,1)                          pointToGetMin = returnMaxIndex(_nextRib.shape.world_vertices,1)                      }                  var pointDiff = Math.abs( pointToGetMin - pointToGetMax )                  //$.writeln("Min: "+pointToGetMin+" Max: "+pointToGetMax+" Diff: "+pointDiff+" Length: "+_nextRib.shape.world_vertices.length)                  //$.writeln("Looking for point diff")                    for(var pt = 0; pt<=pointDiff; pt++){                      //$.writeln(pt)                      //if(direction)                      var idx = pt + pointToGetMin                      //$.writeln("Last Point")                      if(idx > _nextRib.shape.world_vertices.length-1) idx = idx-_nextRib.shape.world_vertices.length                      //$.write("pt "+pt+" idx ")                      //$.write(idx)                      //var idx = ( pt < _nextRib.shape.world_vertices.length-1) ? pt : Math.abs( pt-_nextRib.shape.world_vertices.length )                      //$.writeln(" x"+Math.round(_nextRib.shape.world_vertices[idx][0])+" y"+Math.round(_nextRib.shape.world_vertices[idx][1]))                      //$.writeln("Pushing into Destination Path")                      pathToDestination.vertices.push(_nextRib.shape.world_vertices[idx])                      pathToDestination.inTangents.push(_nextRib.shape.inTangents[idx])                      pathToDestination.outTangents.push(_nextRib.shape.outTangents[idx])                      //check next point                      if(pt==pointDiff){                        newIdx = idx+1                        if(newIdx > _nextRib.shape.world_vertices.length-1) newIdx = newIdx-_nextRib.shape.world_vertices.length                        //check the direction of the next point.                        //$.write(_nextRib.shape.world_vertices[idx][0])                        //$.write(",")                        //$.writeln(_nextRib.shape.world_vertices[idx][1])                        //$.write(_nextRib.shape.world_vertices[newIdx][0])                        //$.write(",")                        //$.writeln(_nextRib.shape.world_vertices[newIdx][1])                        if(direction.y=="down" && _nextRib.shape.world_vertices[newIdx][1]>_nextRib.shape.world_vertices[idx][1]){                          //$.writeln("Bingo on Down")                          //$.writeln("Pushing into Destination Path")                          pathToDestination.vertices.push(_nextRib.shape.world_vertices[newIdx])                          pathToDestination.inTangents.push(_nextRib.shape.inTangents[newIdx])                          pathToDestination.outTangents.push(_nextRib.shape.outTangents[newIdx])                        }else if(direction.y == "up" && _nextRib.shape.world_vertices[newIdx][1] < _nextRib.shape.world_vertices[idx][1]){                          //$.writeln("Pushing into Destination Path")                          pathToDestination.vertices.push(_nextRib.shape.world_vertices[newIdx])                          pathToDestination.inTangents.push(_nextRib.shape.inTangents[newIdx])                          pathToDestination.outTangents.push(_nextRib.shape.outTangents[newIdx])                        }                      }                    }                  //$.writeln("Done Looking")                }              }            }            //$.writeln("Complete")            //$.writeln(JSON.stringify(pathToDestination))      }// if(comp !=null)      //add last point to destination      pathToDestination.vertices.push(home)      pathToDestination.inTangents.push([0,0])      pathToDestination.outTangents.push([0,0])      var pathShape = new Shape()  			  pathShape.vertices = pathToDestination.vertices          pathShape.inTangents = pathToDestination.inTangents          pathShape.outTangents = pathToDestination.outTangents  			  pathShape.closed = false          return pathShape}function returnCurrentLayer(layers,index){    //$.writeln("checking")    //$.writeln(layers.length)    for(var j =0; j<layers.length; j++){      if(layers[j].index == index )        return layers[j]    }    //$.writeln("nomatch")    return -1  }  function returnCurrentRow(layersByRow,layer){    for(var r = 0; r < layersByRow.length; r++)        if(layersByRow[r].indexOf(layer)>-1)          return r      return -1  }